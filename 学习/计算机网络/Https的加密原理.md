# Https的安全原理

## HTTPS的加解密流程

![图片](../../图片/640-20210331173353234)

1. 用户在浏览器发起HTTPS请求（如 https://www.mogu.com/），默认使用服务端的443端口进行连接；
2. HTTPS需要使用一套**CA数字证书**，证书内会附带一个**公钥Pub**，而与之对应的**私钥Private**保留在服务端不公开；
3. 服务端收到请求，返回配置好的包含**公钥Pub**的证书给客户端；
4. 客户端收到**证书**，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；
5. 客户端生成一个用于对称加密的**随机Key**，并用证书内的**公钥Pub**进行加密，发送给服务端；
6. 服务端收到**随机Key**的密文，使用与**公钥Pub**配对的**私钥Private**进行解密，得到客户端真正想发送的**随机Key**；
7. 服务端使用客户端发送过来的**随机Key**对要传输的HTTP数据进行对称加密，将密文返回客户端；
8. 客户端使用**随机Key**对称解密密文，得到HTTP数据明文；
9. 后续HTTPS请求使用之前交换好的**随机Key**进行对称加解密。



## 准备**两组公钥私钥**呢，是不是可以解决双向通信问题？来看下面这个过程。

问题产生: 一对公私钥只可以单向传输

1. 服务端有非对称加密的公钥A1，私钥A2；
2. 客户端有非对称加密的公钥B1，私钥B2；
3. 客户端向服务端发起请求，服务端将公钥A1返回给客户端；
4. 浏览器收到公钥A1，将自己保存的公钥B1发送给服务端；
5. 之后浏览器所有向客户端发送的数据，使用公钥B1加密，客户端可以使用私钥B2解密；
6. 客户端所有向服务端发送的数据，使用公钥A1加密，服务端可以使用私钥A2解密

缺点: **非对称加解密耗时要远大于对称加解密**，对性能有很大损耗，大家的使用体验很差。

## 原理

客户端和服务端通过非对称密钥(公私钥) 加密 需要传输的对称密钥(私钥)  在此过程会有中间人劫持问题

<img src="../../图片/640-7183194." alt="图片" style="zoom: 67%;" />

解决方案: 通过客户端和服务端都信任的CA机构 的非对称密钥中的私钥对需要传输的私钥进行加签(hash签名) 通过公钥验签(公钥加密与传输的签名对比)

