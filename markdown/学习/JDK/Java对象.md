# java类

## 类生命周期

**加载 ——>链接(验证——>准备——>解析<支持动态绑定（晚期绑定)其他均为顺序执行>)——>初始化——>使用(对象实例化——>垃圾收集——>对象终结)——>卸载**

![img](../../markdown/图片/1336595-20200122153244250-560099123.png)

### 加载

简单来说，加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。

这里有两个重点：

- **字节码来源**。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译
- **类加载器**。一般包括**启动类加载器**，**扩展类加载器**，**应用类加载器**，以及用户的**自定义类加载器**。

**注：为什么会有自定义类加载器？**

- 一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。
- 另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。

### 验证

主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。

包括对于**文件格式的验证**，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？

对于**元数据的验证**，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？

对于**字节码的验证**，保证程序语义的合理性，比如要保证类型转换的合理性。

对于**符号引用的验证**，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？

### 准备

主要是为类变量（注意，不是实例变量）分配内存，并且赋予**初值**。

特别需要注意，**初值，不是代码中具体写的初始化的值**，而是Java虚拟机根据不同变量类型的默认初始值。

比如8种**基本类型**的初值，默认为0；**引用类型**的初值则为null；**常量**的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456

### 解析

将常量池内的符号引用替换为直接引用的过程。

两个重点：

- **符号引用**。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。
- **直接引用**。可以理解为一个内存地址，或者一个偏移量。比如**类方法，类变量**的直接引用是指向方法区的**指针**；而**实例方法，实例变量**的直接引用则是从实例的头指针开始算起到这个实例变量位置的**偏移量**

举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。

在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。



### 初始化

这个阶段主要是对**类变量**初始化，是执行类构造器的过程。

换句话说，只对static修饰的变量或语句进行初始化。

如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。

如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。



## 创建对象方式

从Java虚拟机层面看,  除了使用new关键字创建对象的方式外，其他方式全部都是通过转变为invokevirtual指令直接创建对象的。

## Java中new一个对象的步骤以及内存分配：

1. 首先执行类加载检查，看一下在常量池中能否定位到这个类的符号引用 （即类的带路径全名），并且检查这个符号引用代表的类是否已被加载、解析和初始化过，即验证是否是第一次使用该类。如果不是第一次使用，那先执行相应的类加载过程

2. 在类加载检查通过后，JVM 分配内存空间 。根据使用的垃圾收集器的不同使用不同的**分配机制**：

    　　* 指针碰撞：假设Java堆的内存是绝对规整的，已经用过的内存都放一边，空闲的内存放在另一边，中间存放着一个指针作为分界点，分配内存时将指针向空闲空间那边挪动一段与对象大小相等的距离。

    * 空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空间的内存是相互交错的，虚拟机必须维护一个空闲列表，记录上哪些内存块是可用的，在分配时候从列表中找到一块足够大的空间划分给对象使用。

3. 内存分配完后，JVM将分配到的内存空间中的数据类型都 初始化为零值（不包括对象头）；
4. JVM 配置对象头信息，比如class类元数据信息、对象的哈希码、对象的GC分代年龄等信息

5. 调用对象的`init()`（构造函数编译后的方法）方法 ,进行实例变量初始化、实例代码块初始化 以及 构造函数初始化

    实例变量与实例代码块之间的调用顺序按照 代码的顺序执行

    对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且放在对超类构造函数的调用语句之后，构造函数本身的代码之前。

6. 在线程栈中新建对象引用 ，并指向堆中刚刚新建的对象实例。

 

# Java对象

## 对象在内存中的存储布局

 `对象大小默认为8字节的整数倍`

Object obj = new Object();  64位下为16字节

对象头 （64位 12字节）

实例字段

填充数据（4字节）

<img src="https://img-blog.csdnimg.cn/2019043023230896.png" alt="java对象内存模型"  />

一个Java对象由对象头(对象标记、类型指针、数组长度)、真实数据，内存对齐三部分组成。

> + **对象头**含有三部分：Mark Word（存储对象自身运行时数据）、Class Metadata Address（存储类元数据的指针）、Array length（数组长度，只有数组类型才有）
>
>   如果是非数组类型，则用2个字宽来存储对象头，如果是数组，则会用3个字宽来存储对象头。在32位处理器中，一个字宽是32位；在64位虚拟机中，一个字宽是64位。
>
>   >* **对象标记**也称Mark Word字段,用于存储对象自身运行时的数据，如hashcode、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等等。
>   >
>   >32位虚拟机中Mark Word格式
>   >
>   >![img](../../markdown/图片/5fd29d3e4c5342d481eae96994d86421~tplv-k3u1fbpfcp-watermark.image)
>   >
>   >64位虚拟机 java对象头会被压缩成32位
>   >
>   >![img](../../markdown/图片/53f6702c63dc4a68b8447f9f3e005ce4~tplv-k3u1fbpfcp-watermark.image)
>   >
>   >​		可以看到，当对象状态为偏向锁时，`Mark Word`存储的是偏向的线程ID；当状态为轻量级锁时，`Mark Word`存储的	是指向线程栈中`Lock Record`的指针；当状态为重量级锁时，`Mark Word`为指向堆中的monitor对象的指针。
>   >
>   >+ 类型指针：JVM根据该指针确定该对象是哪个类的实例化对象。
>   >+ 数组长度：只有数组类型才有
>
> + 真实数据:  自然是对象的属性值。
>
> + 内存补齐:  是当数据不是对齐数的整数倍的时候，进行调整，使得对象的整体大小是对齐数的整数倍方便寻址。典型的以空间换时间的思想。

## 分配对象

**Java 中对象地址操作主要使用 Unsafe 调用了 C 的 allocate 和 free 两个方法，分配方法有两种：**

- **空闲链表（free list）：** 通过额外的存储记录空闲的地址，将随机 IO 变为顺序 IO，但带来了额外的空间消耗。
- **碰撞指针（bump pointer）：** 通过一个指针作为分界点，需要分配内存时，仅需把指针往空闲的一端移动与对象大小相等的距离，分配效率较高，但使用场景有限。



## 解决多线程下对象分配内存空间存在并发冲突问题

1. 将分配内存空间的动作进行同步处理 ：**JVM采用CAS算法配上失败重试的方式保证了分配内存空间操作的原子性。**

2. **TLAB**:  Thread Local Allocation Buffer 的简写，基于 CAS 的独享线程（Mutator Threads）可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。

## 对象访问定位问题

句柄访问（间接访问） 和 直接指针访问 两种：

1. 句柄访问：

  Java堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象句柄位置，而句柄中包含了对象实例数据内存地址和类的元数据内存地址。

​    ![0](http://note.youdao.com/yws/public/resource/5b20ebcdf1db1515aa330a7aab9d4159/xmlnote/8D49297FFFFC45AA81AD9E81EB560C79/9F9C9C25258F46E9B55C95AEF9651BDA/6354)

2. 直接指针访问：

引用指向堆中存储的对象实例数据，和对象类元数据的指针

​    ![0](http://note.youdao.com/yws/public/resource/5b20ebcdf1db1515aa330a7aab9d4159/xmlnote/8D49297FFFFC45AA81AD9E81EB560C79/C5B43B2E0B8B4039B87625B8FAC64DF2/6352)

## 一个实例变量在对象初始化的过程中会被赋值几次？（最多4次）

* JVM在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个时候实例变量被第一次赋值，这个赋值过程是没有办法避免的。

* 如果我们在声明实例变量x的同时对其进行了赋值操作，那么这个时候，这个实例变量就被第二次赋值了。

* 如果我们在实例代码块中，又对变量x做了初始化操作，那么这个时候，这个实例变量就被第三次赋值了。

* 如果我们在构造函数中，也对变量x做了初始化操作，那么这个时候，变量x就被第四次赋值。

  也就是说，在Java的对象初始化过程中，**一个实例变量最多可以被初始化4次。**

## 类的初始化过程与类的实例化过程的异同？

* 类的初始化是指**类加载过程中的准备阶段**对类变量(**静态的**（变量，方法，代码块) 不是实例变量)赋初始值,   同时在会开辟一块存储空间用来存放静态的数据。初始化只在类加载的时候执行一次。

* 类的实例化是指在**类完全加载到内存中后创建对象的过程**,  这个过程中会在堆中开辟内存，将一些非静态的方法，变量存放在里面。在程序执行的过程中，可以创建多个对象，既多次实例化。每次实例化都会开辟一块新的内存。

### 类初始化顺序 

​	按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息.

1. **初始化父类中的静态成员变量和静态代码块**

2. **初始化子类中的静态成员变量和静态代码块** 

### 类实例化的一般过程是

执行<clinit>()方法（clinit是class initialize的简写）运行没有static修饰的赋值语句和执行语句。

​		**父类的类构造器`<clinit>()` -> 子类的类构造器`<clinit>()` -> 父类的成员变量和实例代码块 -> 父类的构造函数 -> 子类的成员		变量和实例代码块 -> 子类的构造函数。**

```java
public class StaticTest { 
  public static void main(String[] args) { 
  staticFunction(); 
	} 
  static StaticTest st = new StaticTest(); 
  static { 
    //静态代码块 
    System.out.println("1"); 
  } 
  { 
    // 实例代码块 
    System.out.println("2"); 
  } 
  StaticTest() {
    // 实例构造器 
    System.out.println("3");
    System.out.println("a=" + a + ",b=" + b); 
  } 
  public static void staticFunction() { 
    // 静态方法 
    System.out.println("4"); 
  } 
  int a = 110; 
  // 实例变量 
  static int b = 112; 
  // 静态变量 
}
  /* 
  Output: 2 3 a=110,b=0 1 4 *///:~
```

**实例初始化不一定要在类初始化结束之后才开始初始化。**

