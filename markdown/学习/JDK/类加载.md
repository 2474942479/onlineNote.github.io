# 类加载详解

## 类的生命周期

**加载 ->链接(验证->准备->解析)->初始化->使用(对象实例化->垃圾收集->对象终结)->卸载**

1.   **加载**

    ​		`将我们编写的java文件编译成.class字节码文件，然后将字节码文件加载到方法区，并在堆中实例化一个java.lang.Class对象，作为方法区中这个类的信息入口。在不同的虚拟机实现的方式不一定相同，hotspot虚拟机是采用需要时在加载的方式，也有其他是先预先加载的。`

2. **链接**

    （1）验证：`确定该类是否符合java语言的规范，有没有属性和行为的重复，继承是否合理，总之，就是保证jvm能够执行` 

    （2）准备：`主要做的就是为由static修饰的成员变量分配内存，并设置默认的初始值` 

    ​			*默认初始值如下*   

				八种基本数据类型默认的初始值 数值类型为0 flate double为0.0 char为'' boolean为false  
    		 	引用类型默认的初始值是null  
				有static final修饰的会直接赋值，例如：static final int x=10；则默认就是10  

    （3）解析：`这一阶段的任务就是把常量池中的符号引用转换为直接引用，说白了就是jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。`

3. **初始化**

    ​	执行类构造器`<clinit>`方法为类进行初始化,因为是类级别的，所以只加载一次。（类中没有静态变量赋值也没有静态语句块时，编译器不会为类生成`<clinit>`方法）
    
    ​		`初始化这个阶段就是将静态变量（类变量）赋值的过程，即只有static修饰的才能被初始化，执行的顺序就是：父类静态变量或着静态代码块，然后是子类静态变量或者子类静态代码块（静态代码块和静态属性按编写顺序进行加载)`
    
4. **使用**

    ​	*在类的使用过程中依然存在以下三步:*   

    ```
    	对象实例化：就是执行类中构造函数的内容，如果该类存在父类JVM会通过显示或者隐示的方式先执行父类的构造函数，在堆内存中为父类的实例变量开辟空间，并赋予默认的初始值，然后在根据构造函数的代码内容将真正的值赋予实例变量本身，然后，引用变量获取对象的首地址，通过操作对象来调用实例变量和方法
    	垃圾收集：当对象不再被引用的时候，就会被虚拟机标上特别的垃圾记号，在堆中等待GC回收 
    	对象的终结：对象被GC回收后，对象就不再存在，对象的生命也就走到了尽头
    ```


5.   **类卸载**

    `类卸载即类的生命周期走到了最后一步，程序中不再有该类的引用，该类也就会被JVM执行垃圾回收，从此生命结束…`



## 类加载器

* 虚拟机自带的加载器

> * 启动类加载器(`BootStrapClassLoader`) C++编写，加载`java`核心库 `java.*`,构造`ExtClassLoader`和`AppClassLoader`。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作                                             
> * 扩展类加载器(`ExtensionClassLoader`)`Java`编写，加载扩展库，如`classpath`中的`jre` ，`javax.*`或者
>     `java.ext.dir` 指定位置中的类，开发者可以直接使用标准扩展类加载器。
> * 应用程序加载器(`AppClassLoader`) 也叫系统类加载器，`java`编写，主要负责加载应用程序的主函数类

* 用户自定义加载器(`CustomClassLoader`)`java`编写,用户自定义的类加载器,可加载指定路径的`class`文件

<img src="C:\Users\24749\AppData\Roaming\Typora\typora-user-images\image-20200921105419155.png" alt="image-20200921105419155" style="zoom: 67%;" />



类加载的双亲委派机制和沙箱机制：保证用户代码不会污染java源代码

> **双亲委派机制**：当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。
>
> **好处**：
>
> ​	防止重复加载同一个`.class`
>
> ​	保证核心`.class`不能被篡改,不会污染java源代码
>
> + 如果要**符合**双亲委派规范，则重写**findClass方法（用户自定义类加载逻辑**)。
> + 要**破坏**的话，重写**loadClass方法(双亲委派的具体逻辑实现)**。
>
> 违反双亲委派机制例子：JDBC
>
> > 你先得知道SPI(Service Provider Interface)，这玩意和API不一样，它是面向拓展的，也就是我定义了这个SPI，具体如何实现由扩展者实现。我就是定了个规矩。
> >
> > JDBC就是如此，在rt.jar里面定义了这个SPI，那mysql有mysql的jdbc实现，oracle有oracle的jdbc实现，反正我java不管你内部如何实现的，反正你们都得统一按我这个来，这样我们java开发者才能容易的调用数据库操作。所以因为这样那就不得不违反这个约束啊，`Bootstrap ClassLoader`就得委托子类来加载数据库厂商们提供的具体实现。因为它的手只能摸到`<JAVA_HOME>\lib`中，其他的它无能为力。这就违反了自下而上的委托机制了。
> >
> > Java就搞了个线程上下文类加载器，通过`setContextClassLoader()`默认情况就是应用程序类加载器然后`Thread.current.currentThread().getContextClassLoader()`获得类加载器来加载
> >
> >
> > 作者：yes的练级攻略
> > 链接：https://juejin.im/post/6844903838927814669
> > 来源：掘金
> > 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 静态代码和非静态代码

`静态代码在初始化阶段被初始化，而费静态代码在使用阶段（实例化一个类的时候）进行初始化`

### 静态代码

> 1. **静态变量**  
>
> > **有两种情况**  
> >
> > > * 静态变量是**基本数据类型**，这种情况下在类的外部不必创建该类的实例就可以直接使用  
> > > * 静态变量是一个**引用**。这种情况比较特殊，主要问题是由于静态变量是一个对象的引用，那么必须**初始化**这个对象之后才能将引用指向它。 
> > > * 因此如果要把一个**引用定义**成static的，就**必须在定义的时候就对其对象进行初始化**
>
> 2. **静态代码块**    
>
> > 静态代码块主要用于**类的初始化**。它只执行一次，**并且在同属于一个类的main函数之前执行**。
> >
> > 静态代码块的特点主要有:  
> >
> > > + 静态代码块会在**类被加载时自动执行**。
> > > + 静态代码块**只能定义在类里面**，**不能定义在方法里面**。
> > > + 静态代码块里的变量都是局部变量，**只在块内有效。**
> > > + 一个类中可以定义多个静态代码块，按顺序执行。
> > > + 静态代码块只能访问**类的静态成员**，而**不允许访问实例成员**。
>
> 3. **静态方法**    
>
> > 与类变量不同，方法（静态方法与实例方法）在内存中只有一份，**无论该类有多少个实例，都共用一个方法**。  
> >
> > 静态方法与实例方法的不同主要有：
> >
> > > + **静态方法可以直接使用**，而实例方法**必须**在**类实例化之后通过对象来调用**。
> > > + 在外部调用静态方法时，可以使用“**类名.方法名**”或者“**对象名.方法名**”的形式。
> > > + 实例方法只能使用这种方式**对象名.方法名**。
> > > + 静态方法只允许访问静态成员。而实例方法中可以访问静态成员和实例成员。
> > > + **静态方法中不能使用this**（因为this是与实例相关的）。
>
> **静态变量和静态代码开的加载顺序**
>
> > 静态变量和static修改的静态代码块 运行的顺序是根据代码编写的先后  
> >
> > 为了避免出现不必要的麻烦， 不管是否有在静态代码块中使用 静态变量， 都应当把**静态变量写在 静态代码块的上方**。 静态常量的情况 和静态变量是一样

> **静态代码块和静态方法的区别**
>
> > **java 静态代码块：**
> >
> > ​		一般情况下,如果有些代码必须**在项目启动前**就执行的时候,需要使用静态代码块,这种代码是**主动执行**的，**它只执行一次，并且在同属于一个类的main函数之前执行**。
> >
> > **静态方法：**
> >
> > ​		需要在**项目启动的时候**就初始化,在不创建对象的情况下,其他程序来**调用**的时候,需要使用静态方法,这种代码是**被动执行的**.
> >
> > 

## 类的加载顺序	

> * **有继承关系的加载顺序**
>
>     >**父类的（静态变量、静态初始化块）=> 子类的（静态变量、静态初始化块）=> 父类的（变量、初始化块、构造器）=> 子类的（变量、初始化块、构造器）**
>     >
>     >```
>     >1. 首先加载父类的静态字段或者静态语句块
>     >2. 子类的静态字段或静态语句块
>     >3. 父类普通变量以及语句块
>     >4. 父类构造方法被加载
>     >5. 子类变量或者语句块被加载
>     >6. 子类构造方法被加载
>     >```
>
> * **单个类的加载顺序**
>
>     >**类内容（静态变量、静态初始化块） => 实例内容（变量、初始化块、构造器）**

​		



