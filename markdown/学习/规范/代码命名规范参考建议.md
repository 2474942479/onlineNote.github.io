# 代码命名规范参考建议

阿里开发规约已经是比较完善的Java规约了，但是个人感觉给出的参考建议并不是太多，本文是结合自己的思考及参考网络优秀博客整理出来的，代码命名规范建议仅供参考。

写代码就像写文章, 好的代码就像好的文章,结构严谨,构思清晰。写代码就像写文章, 一不留神就成流水账，为避免这种情况作为软件开发工程师，重要的是设计而不是实现。

本文的目的在于给出参考建议，具体编程风格有团队讨论定制，一旦形成就要具有契约精神。

契约精神: 做到有法可依，有章可循。规范由团队讨论合理定制，统一编程风格。

 (ps: 文中仅是个人建议，若有异议请留言评论，一起讨论进步学习) 🚀

# 一、类命名

## 1. 抽象类/基类

适用的设计模式为模板模式。抽象是自下往上的设计。由具体实现推断出抽象方法。必须以Abstract开头。基础类提供公用的方法用Base。



| Abstract 或者 Base 开头 | BaseUserService |
| :---------------------: | --------------- |

## 2. 枚举类

- 枚举是由JVM来保证的单例。可以用来做单例类。
- 枚举类常用作值判断,不建议每次进行循环判断得到实例。建议由内部维护一个map类型,当做cache。此方法建议放在static静态代码块中实现。(空间换时间,高频调用枚举,更建议使用)

| Enum 作为后缀 | GenderEnum |
| :-----------: | ---------- |

## 3. 工具类

工具类常为无状态对象,无状态对象都是线程安全对象,建议使用 `final` 修饰。

以Utils结尾的工具类不要当做Bean来使用,并且包含业务语义的东西。

工具类中避免出现业务属性, 如果出现业务属性,抽象出领域层,或者参考处理特殊类。

| Utils作为后缀 | StringUtils |
| ------------- | ----------- |

## 4. 异常类

保持异常链,避免异常链丢失。web端应用,可以做全局异常拦截，避免堆栈信息输出到前端

| Exception结尾 | RuntimeException |
| ------------- | ---------------- |

## 5. 接口实现类

里式替换。@六、里式替换原则详细描述

| 接口名+ Impl | UserServiceImpl |
| ------------ | --------------- |

## 6. 设计模式相关类

| Builder，Factory等 | 当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory |
| ------------------ | ------------------------------------------------------------ |

## 7. 处理特定功能的

|                               |                                                              |
| ----------------------------- | ------------------------------------------------------------ |
| Handler，Predicate, Validator | 表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate |

## 8. 测试类

测试方法以Test为后缀,并注明测试场景。

| Test结尾 | UserServiceTest， 表示用来测试UserService类的 |
| -------- | --------------------------------------------- |

## 9. 领域模型载体

|              |                               |
| ------------ | ----------------------------- |
| DTO/*Request | 数据传输对象                  |
| Model        | 业务对象 //阿里规约中的BO     |
| VO           | 数据展示对象,用于承载页面数据 |
| DO           | 数据持久化对象                |

# 二、方法命名

## 1. 布尔判断方法

注：Prefix-前缀，Suffix-后缀，Alone-单独使用

| **位置** | **单词** | **意义**                                                     | **例**        |
| -------- | -------- | ------------------------------------------------------------ | ------------- |
| Prefix   | is       | 对象是否符合期待的状态                                       | isValid       |
| Prefix   | can      | 对象**能否执行**所期待的动作                                 | canRemove     |
| Prefix   | should   | 调用方执行某个命令或方法是**好还是不好**,**应不应该**，或者说**推荐还是不推荐** | shouldMigrate |
| Prefix   | has      | 对象**是否持有**所期待的数据和属性                           | hasObservers  |
| Prefix   | needs    | 调用方**是否需要**执行某个命令或方法                         | needsMigrate  |

## 2. **检查的方法**

注：Prefix-前缀，Suffix-后缀，Alone-单独使用

| **单词** | **意义**                                             | **例**         |
| -------- | ---------------------------------------------------- | -------------- |
| ensure   | 检查是否为期待的状态，不是则抛出异常或返回error code | ensureCapacity |
| validate | 检查是否为正确的状态，不是则抛出异常或返回error code | validateInputs |



## **3. 按需求才执行的方法**

注：Prefix-前缀，Suffix-后缀，Alone-单独使用

| **位置** | **单词**  | **意义**                                  | **例**                 |
| -------- | --------- | ----------------------------------------- | ---------------------- |
| Suffix   | IfNeeded  | 需要的时候执行，不需要的时候什么都不做    | drawIfNeeded           |
| Prefix   | might     | 同上                                      | mightCreate            |
| Prefix   | try       | 尝试执行，失败时抛出异常或是返回errorcode | tryCreate              |
| Suffix   | OrDefault | 尝试执行，失败时返回默认值                | getOrDefault           |
| Suffix   | OrElse    | 尝试执行、失败时返回实际参数中指定的值    | getOrElse              |
| Prefix   | force     | 强制尝试执行。error抛出异常或是返回值     | forceCreate, forceStop |

## **4. 异步相关方法**

注：Prefix-前缀，Suffix-后缀，Alone-单独使用

| **位置**        | **单词**     | **意义**                                     | **例**                |
| --------------- | ------------ | -------------------------------------------- | --------------------- |
| Prefix          | blocking     | 线程阻塞方法                                 | blockingGetUser       |
| Suffix          | InBackground | 执行在后台的线程                             | doInBackground        |
| Suffix          | Async        | 异步方法                                     | sendAsync             |
| Suffix          | Sync         | 对应已有异步方法的同步方法                   | sendSync              |
| Prefix or Alone | schedule     | Job和Task放入队列                            | schedule, scheduleJob |
| Prefix or Alone | post         | 同上                                         | postJob               |
| Prefix or Alone | execute      | 执行异步方法（注：我一般拿这个做同步方法名） | execute, executeTask  |
| Prefix or Alone | start        | 同上                                         | start, startJob       |
| Prefix or Alone | cancel       | 停止异步方法                                 | cancel, cancelJob     |
| Prefix or Alone | stop         | 同上                                         | stop, stopJob         |



## **5. 回调方法**

注：Prefix-前缀，Suffix-后缀，Alone-单独使用

| **位置** | **单词** | **意义**                   | **例**       |
| -------- | -------- | -------------------------- | ------------ |
| Prefix   | on       | 事件发生时执行             | onCompleted  |
| Prefix   | before   | 事件发生前执行             | beforeUpdate |
| Prefix   | pre      | 同上                       | preUpdate    |
| Prefix   | will     | 同上                       | willUpdate   |
| Prefix   | after    | 事件发生后执行             | afterUpdate  |
| Prefix   | post     | 同上                       | postUpdate   |
| Prefix   | did      | 同上                       | didUpdate    |
| Prefix   | should   | 确认事件是否可以发生时执行 | shouldUpdate |

## **6. 操作对象生命周期的方法**

注：Prefix-前缀，Suffix-后缀，Alone-单独使用

| **单词**   | **意义**                       | **例**          |
| ---------- | ------------------------------ | --------------- |
| initialize | 初始化。也可作为延迟初始化使用 | initialize      |
| pause      | 暂停                           | onPause ，pause |
| stop       | 停止                           | onStop，stop    |
| abandon    | 销毁的替代                     | abandon         |
| destroy    | 同上                           | destroy         |
| dispose    | 同上                           | dispose         |



## **7. 与集合操作相关的方法**

注：Prefix-前缀，Suffix-后缀，Alone-单独使用

| **单词** | **意义**                     | **例**     |
| -------- | ---------------------------- | ---------- |
| contains | 是否持有与指定对象相同的对象 | contains   |
| add      | 添加                         | addJob     |
| append   | 添加                         | appendJob  |
| insert   | 插入到下标n                  | insertJob  |
| put      | 添加与key对应的元素          | putJob     |
| remove   | 移除元素                     | removeJob  |
| enqueue  | 添加到队列的最末位           | enqueueJob |
| dequeue  | 从队列中头部取出并移除       | dequeueJob |
| push     | 添加到栈头                   | pushJob    |
| pop      | 从栈头取出并移除             | popJob     |
| peek     | 从栈头取出但不移除           | peekJob    |
| find     | 寻找符合条件的某物           | findById   |



## **8. 数据增删改查相关的方法**

注：Prefix-前缀，Suffix-后缀，Alone-单独使用

| **单词** | **意义**                               | **例**        |
| -------- | -------------------------------------- | ------------- |
| create   | 新创建                                 | createAccount |
| new      | 新创建                                 | newAccount    |
| from     | 从既有的某物新建，或是从其他的数据新建 | fromConfig    |
| to       | 转换                                   | toString      |
| update   | 更新既有某物                           | updateAccount |
| load     | 读取                                   | loadAccount   |
| fetch    | 远程读取                               | fetchAccount  |
| delete   | 删除                                   | deleteAccount |
| remove   | 删除                                   | removeAccount |
| save     | 保存                                   | saveAccount   |
| store    | 保存                                   | storeAccount  |
| commit   | 保存                                   | commitChange  |
| apply    | 保存或应用                             | applyChange   |
| clear    | 清除数据或是恢复到初始状态             | clearAll      |
| reset    | 清除数据或是恢复到初始状态             | resetAll      |

## **9. 成对出现的动词**

注：Prefix-前缀，Suffix-后缀，Alone-单独使用

| **单词**       | **意义**          |
| -------------- | ----------------- |
| get获取        | set 设置          |
| add 增加       | remove 删除       |
| create 创建    | destory 移除      |
| start 启动     | stop 停止         |
| open 打开      | close 关闭        |
| read 读取      | write 写入        |
| load 载入      | save 保存         |
| create 创建    | destroy 销毁      |
| begin 开始     | end 结束          |
| backup 备份    | restore 恢复      |
| import 导入    | export 导出       |
| split 分割     | merge 合并        |
| inject 注入    | extract 提取      |
| attach 附着    | detach 脱离       |
| bind 绑定      | separate 分离     |
| view 查看      | browse 浏览       |
| edit 编辑      | modify 修改       |
| select 选取    | mark 标记         |
| copy 复制      | paste 粘贴        |
| undo 撤销      | redo 重做         |
| insert 插入    | delete 移除       |
| add 加入       | append 添加       |
| clean 清理     | clear 清除        |
| index 索引     | sort 排序         |
| find 查找      | search 搜索       |
| increase 增加  | decrease 减少     |
| play 播放      | pause 暂停        |
| launch 启动    | run 运行          |
| compile 编译   | execute 执行      |
| debug 调试     | trace 跟踪        |
| observe 观察   | listen 监听       |
| build 构建     | publish 发布      |
| input 输入     | output 输出       |
| encode 编码    | decode 解码       |
| encrypt 加密   | decrypt 解密      |
| compress 压缩  | decompress 解压缩 |
| pack 打包      | unpack 解包       |
| parse 解析     | emit 生成         |
| connect 连接   | disconnect 断开   |
| send 发送      | receive 接收      |
| download 下载  | upload 上传       |
| refresh 刷新   | synchronize 同步  |
| update 更新    | revert 复原       |
| lock 锁定      | unlock 解锁       |
| check out 签出 | check in 签入     |
| submit 提交    | commit 交付       |
| push 推        | pull 拉           |
| expand 展开    | collapse 折叠     |
| begin 起始     | end 结束          |
| start 开始     | finish 完成       |
| enter 进入     | exit 退出         |
| abort 放弃     | quit 离开         |
| obsolete 废弃  | depreciate 废旧   |
| collect 收集   | aggregate 聚集    |

## **10. 获取必须的参数**

| getRequiredProperty | 获取必须的参数,否则报错,该方法一般都要抛出异常          |
| ------------------- | ------------------------------------------------------- |
| getProperty         | 非必须参数,可以返回null，不报错，调用方自行判断处理逻辑 |

## **11. 获取数据并对数据进行某种处理**

注：Prefix-前缀，Suffix-后缀，Alone-单独使用

| 位置   | 单词         | 意义                                                     | 例子                |
| ------ | ------------ | -------------------------------------------------------- | ------------------- |
| Prefix | resolve      | 解决某些问题,比如对文本占位符进行填充,并获取到填充后的值 | resolvePlaceholders |
| Suffix | Placeholders | 占位符相关命名                                           | resolvePlaceholders |

#  

# 变量命名



## Map结构

### 数据映射(仅仅用做关联)

key2ValueMappingMap

### 数据映射(缓存使用)

key2ValueCacheMap



#  

# 三、方法编程建议



写好业务代码,说简单也简单,说难也难,就想前文一样,流水账谁都会写,如何层次清晰,结构完整是我们要关注思考的。(编程时候的关注点, 编程时候的细节习惯，往往能让我们快速的提高自己的业务编程能力和形成自己的编程方法论,从而提高自己的核心竞争力)



1. 业务逻辑没问题。
2. 关注性能,能减少RPC调用就减、能减少循环就减少。
3. 方法的复用性, 增加方法的复用性的设计哲学就是单一职责。

## 1. 方法复杂度

凡事逻辑判断语句均为复杂度。当一个方法中出现了大于等于10个复杂度。建议根据

方法实现进行业务抽离。两个建议点(1. 方法单一职责 2. 方法可重复利用 3. 是否能用策略模式或者命令模式)

## 2. 方法长度及宽度

- 长度: 方法的长度建议控制在80-120行以内。满足一屏可以放下。
- 宽度: 当方法超过3个及以上入参,建议使用对象封装(对象容易后期扩展,且不会出现眼花缭乱现象)

## 3. 关注方法优化编辑器提示

减少出现黄色警告⚠️, 最好不要出现警告。编辑器的警告都是优化点,需要在编程时候考虑进去。

eg: 性能优化、命名不规范、重复代码 。 单词拼错的检查，也是黄色波浪线，要注意哦

## 4. 方法重复代码

贫血模型的标志性问题

重复代码编辑器会提出警告,此种现象,强烈建议不要出现

## 5. 方法注释

“悟以往之不谏，知来者之可追”

 开发者是以参与者的身份进来的，项目的伴随着是公司, 一切为了项目的健壮性和可继承性。请务必重视注释的意义, 注释再小也是大事,养成良好的编码习惯。



- 类注释。 可以将当前类的业务进行大概描述或者是自己设计的思路和处理问题的思路
- 方法及参数注释。如果写的全那么编辑提提示的时候是有好处的。如果你想ba



## 6. 事务方法处理

事务方法往往会占用数据库连接,如果事务方法耗时过长,会导致应用数据库连接池不够用,同时增加DB的连接数量。既影响应用服务器同时给数据库服务器造成压力。所以处理事务方法时候要进行细粒度进行操作。尽量避免

事务方法中包含了大量不必要的完成调用。潜规则: (把自己的db生命安全,交给服务服务方式一种很危险的行为,别人服务抖了一下,可能自己没有影响,但是把你搞挂了就很难受了)



建议对要求保证事务的方法进行细粒度操作:



- 使用编程式事务进行操作,Session要注意释放,否则有严重问题

```
SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH,false);
//提交
sqlSession.commit();
//回滚
sqlSession.rollback();
//切记必须关闭
sqlSession.close();
```

- 或者使用Spring提供的编程式事务进行coding

```java
package com.idanchuang.purchase.center.core.common.util;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;

/**
 * 声明式事务固有好处,比如当代码块中只涉及到数据库操作时候。这种是最佳使用场景。 <br>
 * 但是往往一些系统中,声明式的使用,会降低性能。如方法中涉及到多个系统的查询或者无关事务的方法。<br>
 * 此时如果 还使用声明式事务是有问题的。就好比把自己系统的生命交给了第三方系统,第三方系统抖一抖,我们跟着抖一抖。
 *
 * 因为在使用声明式事务时候,要考虑下这个问题。Spring 框架也为我们提供了编程式事务,如下<br>
 * </> 可以使用Spring原生的事务,也可以使用当前工具类,工具类并没有技术含量,主要是将我们不需要使用的东西给屏蔽了<br>
 * 让我们只专注于业务。
 *
 * @see TransactionTemplate#execute(TransactionCallback)
 */
@Component
public class PmsTransactionTemplate {

    /**
     * 事务方法
     */
    private TransactionTemplate transactionTemplate;

    @Autowired
    public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }

    /**
     * 执行事务动作(有返回值)
     */
    public <T> T transactionAction(TransactionCodeBlockSupplier<T> codeBlockSupplier) {
        return transactionTemplate.execute(transactionStatus -> codeBlockSupplier.transactionCallbackAction());
    }

    /**
     * 执行事务动作
     */
    public void transactionAction(TransactionCodeBlock codeBlock) {
        transactionTemplate.execute(transactionStatus -> {
            codeBlock.transactionAction();
            return null;
        });
    }

    /**
     * 事务代码块,代码块里面的操作会放在一个单独的事务中
     */
    @FunctionalInterface
    public interface TransactionCodeBlock {

        /**
         * 事务动作
         */
        void transactionAction();
    }

    /**
     * 事务代码块(包含返回值),代码块里面的操作会放在一个单独的事务中
     */
    @FunctionalInterface
    public interface TransactionCodeBlockSupplier<T> {

        /**
         * 事务动作(包含返回值)
         *
         * @return T 返回值泛型
         */
        T transactionCallbackAction();
    }
}
```

- 将必须要保证事务的方法抽出到单独的事务方法并加上事务注解,减少不必要的远程调用嵌套在事务方法中



## 7. 批量插入

Mybatis-plus提供了批量操作动作,但是要继承IService接口实现。可以使用下面代码进行实现,批量操作

```java
package com.lxchinesszz.blog;

import org.apache.ibatis.session.ExecutorType;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import java.util.function.Consumer;

@Component
public class BatchExecuteTemplate {

    private SqlSessionFactory defaultSqlSessionFactory;

    @Autowired
    public void setDefaultSqlSessionFactory(SqlSessionFactory defaultSqlSessionFactory) {
        this.defaultSqlSessionFactory = defaultSqlSessionFactory;
    }

    /**
     * 批量操作动作内部类
     *
     * @param <T> mapper类
     */
    public static class BatchExecuteAction<T> {

        /**
         * 当前批量操作回话
         */
        private final SqlSession sqlSession;

        /**
         * mapper类
         */
        private final T mapper;

        public BatchExecuteAction(SqlSession sqlSession, T mapper) {
            this.sqlSession = sqlSession;
            this.mapper = mapper;
        }

        private SqlSession getSqlSession() {
            return sqlSession;
        }

        private T getMapper() {
            return mapper;
        }

        /**
         * 批量执行
         *
         * @param apply 执行动作
         */
        public void batchExecute(Consumer<T> apply) {
            try {
                //1. 执行用户批量动作
                apply.accept(getMapper());
                //2. 无异常提交
                getSqlSession().commit();
            } catch (Exception e) {
                e.printStackTrace();
                //3. 异常回滚
                getSqlSession().rollback();
            } finally {
                //4. 完成关闭回话
                getSqlSession().close();
            }
        }
    }


    public <T> BatchExecuteAction<T> getBatchMapper(Class<T> mapperType) {
        //获取批量回话,事务模式为不自动提交。
        SqlSession sqlSession = defaultSqlSessionFactory.openSession(ExecutorType.BATCH, false);
        return new BatchExecuteAction<>(sqlSession, sqlSession.getMapper(mapperType));
    }


}
```



# 四、领域驱动、面向对象设计

面向对象思想来解决方法冗长的coding，提高coding能力。

## 1. 领域设计的认识

领域划分,用另外一个词形容也非常的合适,就是业务模块化。所有能力都进行能力化抽象,形成模块,形成领域。 当遇到新的业务逻辑,底层的数据结构和数据关系肯定也是一样的。那么就可以像堆积木一样,根据这些模块快速的组装成新的业务逻辑。快速的实现业务的迭代和升级。

关于这个问题,需要结合自己的业务系统来进行抽象和设计。

设计核心: 用面向对象的设计思想对业务进行解耦来做到领域划分。

关键字: 方法解耦，单一职责。可以理解为一个方法只做一个事情, 但是如果这个事情很复杂就可以对复杂的事情在进行拆分,同样遵守单一职责原则。

## 2. 层次划分

### 基础层(不包含业务逻辑) 

注意: 基础层只做适配不做业务

- DB操作以Mapper结尾, 数据实体以DO做后缀
- 外部调用以Client(Http协议)/Instruction(Rpc协议)    --该层仅仅做数据适配,不做业务处理。模型为DTO

### 领域层(偏向领域的业务逻辑) 

以Manager,单一职责。(丰富的领域层能有效减少重复代码量,同时方便统一管理和扩展)

如: 

- 业务中经常需要对仓库信息进行操作。则可以对仓库作为一个领域提供,丰富的能力。这样就可以避免业务层中，出现对仓库信息过多的操作。同时具有通用性。
- 业务中经常会出现关系表，如入库单，入库单明细等操作，则可以对入库单进行领域封装。提供根据入库单

   直接查询，入库单和入库单明细的方法。避免这中同样的逻辑，过多的耦合在业务层。切不具有通用性的场景。

### 业务层(对领域层的业务编排) 

以Service结尾

- service只做一件事情,如果事情很复杂但不具备公共性和领域特性,就在service层创建单一职责的方法。
- 如果事情很复杂但是具备公共性也具备领域的特性,抽象出Manager领域层,方便扩展,同时也可以供其他业务使用。

### 外观层(可以提供能力,可以提供视图)。

以Resource、Facade结尾

有一个完善的领域层,可以方便快速便捷的对业务进行扩展。与其对立的就是贫血模型。没有领域层只有业务层,业务逻辑都堆积在业务层。典型的面向过程设计。



![image](https://cdn.nlark.com/yuque/0/2020/png/182855/1603524590555-e1a108b1-35f4-4754-8877-9740d41f0ae5.png?x-oss-process=image%2Fresize%2Cw_1500) 

## 3. 层次依赖模型

maven多模块应用和单模块应用通用。

一定要控制项目的依赖情况。

①service只能出现领域层的依赖, 领域层只能存在dao层和第三方服务层。

②各个层代码不能平行调用(出现平行调用逻辑,要抽象出领域层来封装)。

 

![image](https://cdn.nlark.com/yuque/0/2020/png/182855/1603524590570-d6d28404-efe6-44c1-a6d3-a248a05865a2.png)

具体代码体现就是

- 以Service命名的类,里面只能存在Manager
- 以Manager命名的类,里面只能存在Dao和Client(Http协议)/Instruction(Rpc协议)封装的第三方调用
- 以Mapper命名的类是对数据库的操作
- 以Client(Http协议)/Instruction(Rpc协议)命名的类,作为适配层与第三方API进行交互封装



## 4. 明确业务模型边界



为什么要明确业务模型边界? 个人理解就像是我们在命名变量一样,要见名知意, 看到他的第一感觉就知道大概是做什么事情。如何做到这样呢? 所以出现了BO/DO/VO/DTO。这就是业务模型的意义。



效果: 短期来看会增加成本,但是一旦团队内部形成约定,明确如何定义,明确如何转换。从长期来看一定是有正作用。业务代码会现在更加层次清晰，减少代码维护成本。



BO: 内部业务模型

DO: 数据库实体

VO: 视图模型,进展示给前端使用

DTO: 数据传输对象

![image.png](https://cdn.nlark.com/yuque/0/2020/png/182855/1605430466725-a0b08a99-e3d0-443e-8320-d137b72704d1.png)

# 五、日志输入与降级



日志是排查问题的主要方式, 合理的日志设计可以提高查询问题的效率。但是日志中要考虑的是格式和降级。

- 格式（方便ELK采集,建立索引优化查询）
- 降级（高并发场景,日志输入的影响性能的关键）

解决方案: 提供日志工具类。减少日志随意性,对日志进行统一管理。

建议中间部门能提供统一日志工具类。

# 六、设计模式六大原则



代码编程时候要向以下这6大原则,进行向其靠拢。

## 1. 开闭原则

一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。



**代码设计建议**

用抽象构建框架，用实现扩展细节因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。



## 2. 单一职责

不要存在多于一个导致类变更的原因通俗的说，即一个类只负责一项职责。



**代码设计建议**

在具体方法编写或者类编写时候,类编写时候业务要单一,方法编写时候实现要单一

反例:

UserService 类中提供了获取商品信息的接口

setUserName(String name)方法的时候,对name的值进行了二次处理。

## 3. **里氏替换原则**

所有引用基类的地方必须能透明地使用其子类的对象。

比如我们在与前端进行联调时候，我们的开发并没有完成，就可以先实现业务接口，做一个mock service。



**代码设计建议**

面向接口编程, 子类能透明替换父类。

## 4. **依赖倒置原则**

高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。



**代码设计建议**

要根据接口或者抽象去设计,不要依赖于细节,eg.项目中要换数据库,不用重新写底层的数据库代码. 就是使用了hibernate一样,替换方言就好了,因为hibernate是根据接口设计的,不同数据库有不同的实现,可以直接使用. eg2: 我生病了要去买药,如果A药铺,没有我就用B药铺买. 因为他们都是药铺,都有一样的功能,可以友好的替换

## **5. 接口隔离原则**

客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。



**代码设计建议**

保持最小的责任。

eg: 接口ConfigurableApplicationContext实现了Lifecycle和Closeable接口。他们其中每个里面定义的接口都很少,为什么不定义到一起呢?

首先第一责任清晰单一,第二做到接口隔离。

当某一个方法只用到生命周期的方法,那么方法就可以写成。

public void stop(Lifecycle lifecycle); 调用时候用->public void stop(new ConfigurableApplicationContext());

public void close(Closeable closeable); 调用时候用->public void close(new ConfigurableApplicationContext());

stop里面的实现就只能调用Lifecycle里面的方法,而不能调用ConfigurableApplicationContext里面的方法。从而来达到接口隔离原则

## 6. **迪米特法则**

一个对象应该对其他对象保持最少的了解。



**代码设计建议**

减少类与类之间的关系,接口隔离也可以做到。



# 七、设计模式



虽然设计模式是个好东西，能够给我们带来各种好处，比如降低对象之间的耦合，增加程序的可复用性、可扩展性、可维护性等等。

但是我们也不应该滥用设计模式(不要为了设计而设计)，设计模式在一定程序上会增加系统的复杂性。我们在写码时应该评估好各方面，避免过度设计。



设计模式一般分为三类：创建型模式、结构型模式、行为型模式。

- 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。
- 结构型模式：把类或对象结合在一起形成一个更大的结构。
- 行为型模式：类和对象如何交互，及划分责任和算法



![image.png](https://cdn.nlark.com/yuque/0/2020/png/182855/1605598713141-cdf9d412-33b2-40ba-aab8-7d596717a165.png)

## 1. 创建型模式

创建型模式简单来说就是用来创建对象的。一共有五种：单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。

1. 单例模式 ：确保某一个类只有一个实例，并且提供一个全局访问点。
2. 建造者模式 ： 用来创建复杂的复合对象。
3. 工厂方法模式 ：让子类来决定要创建哪个对象。
4. 抽象工厂模式 ：创建多个产品族中的产品对象。
5. 原型模式 ：通过复制原型来创建新对象。



## 2. 结构型模式

结构型模式主要是用于处理类或者对象的组合。一共有七种：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

1. 代理模式 ：控制客户端对对象的访问。
2. 组合模式 ：将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理。
3. 适配器模式 ：将原来不兼容的两个类融合在一起。
4. 装饰者模式 ：为对象添加新功能。
5. 享元模式 ：使用对象池来减少重复对象的创建。
6. 外观模式 ：对外提供一个统一的接口用来访问子系统。
7. 桥接模式 ：将两个能够独立变化的部分分离开来。



## 3. 行为型模式



行为型模式主要是描述类或者对象是怎样交互和怎样分配职责的。一共有十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

1. 策略模式 ：封装不同的算法，算法之间能互相替换。
2. 状态模式 ：根据不同的状态做出不同的行为。
3. 责任链模式 ：将事件沿着链去处理。
4. 观察者模式 ：状态发生改变时通知观察者，一对多的关系。
5. 模板方法模式 ：定义一套流程模板，根据需要实现模板中的操作。
6. 迭代器模式 ：提供一种方法顺序访问一个聚合对象中的各个元素。
7. 备忘录模式 ：保存对象的状态，在需要时进行恢复。
8. 访问者模式 ：稳定数据结构中，定义新的操作行为。
9. 中介者模式 ：将网状结构转变为星型结构，所有行为都通过中介。
10. 解释器模式 ：定义语法，并对其进行解释。
11. 命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做。



# 八、版本迭代

master分支版本后缀 ${大版本号}.${0进位}.${迭代版本号}.RELEASE

test分支版本号 ${大版本号}.${0进位}.${迭代版本号}.SNAPSHOP

迭代版本可追踪，避免出现jar包覆盖无法追踪

迭代版本升级,必须升级迭代版本号。避免出现jar包覆盖无法追踪

## 1. 大版本定义

GIC1.0  GIC2.0 GIC3.0

## 2. 迭代版本号

GIC1.0.1  GIC1.0版本的第一个迭代

GIC1.1.0  GIC1.0版本的第十个迭代

GIC2.0.2  GIC2.0版本的第二个迭代

GIC2.1.0  GIC2.0版本的第十个迭代

# 九、代码格式化

团队内统一格式化模板,解决多人共同开发场景,代码格式化导致的git提交冲突问题

 ![image.png](https://cdn.nlark.com/yuque/0/2020/png/182855/1605431605969-6cc9621c-653c-457b-af38-d2f0d04d49c2.png?x-oss-process=image%2Fresize%2Cw_1500)

```
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<profiles version="12">
    <profile kind="CodeFormatterProfile" name="P3C-CodeStyle" version="13">
        <!--可变参数的... Idea没有对应的配置项，强制insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_ellipsis" value="insert"/>
        <!--枚举值之间 Idea没有对应的配置项，强制insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations" value="insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=Java:SPACE_BEFORE_COMMA-->
        <!--org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=Java:SPACE_BEFORE_COMMA
        由于IDEA只有一个SPACE_BEFORE_COMMA选项，所以统一设置 insert_space_before_comma 为 do not insert
        -->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments"
                 value="do not insert"/>

        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations"
                 value="do not insert"/>
        <!--insert_space_before_comma end-->

        <!--org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=Java:SPACE_AFTER_COMMA_IN_TYPE_ARGUMENTS-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments" value="insert"/>
        <!--IDEA只有一个配置项SPACE_AFTER_COMMA，insert_space_after_comma*统一设置成insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation" value="insert"/>
        <!--insert_space_after_comma end-->


        <!--org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=Java:SPACE_BEFORE_COLON-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for" value="insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=Java:SPACE_AFTER_COLON-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement" value="insert"/>

        <!--IDEA不支持配置，默认do not insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case" value="do not insert"/>
        <!--这个在Eclipse也没有找到配置的地方-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case" value="do not insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_before_semicolon=Java:SPACE_BEFORE_SEMICOLON
        程序导入的时候强制将SPACE_BEFORE_SEMICOLON设置为false
        -->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for" value="do not insert"/>

        <!--SPACE_AFTER_SEMICOLON=true-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources" value="insert"/>

        <!--IDEA不支持配置,do not insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant"
                 value="do not insert"/>
        <setting
                id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration"
                value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration"
                 value="do not insert"/>

        <!--IDEA不支持，使用默认-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator" value="do not insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=Java:<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_binary_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_binary_operator" value="insert"/>

        <!--IDEA不支持配置，使用如下值，两者对应-->
        <setting
                id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference"
                value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters"
                 value="do not insert"/>

        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters"
                 value="insert"/>
        <setting
                id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference"
                value="do not insert"/>

        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments"
                 value="do not insert"/>
        <setting
                id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference"
                value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters"
                 value="do not insert"/>

        <!--Java:SPACE_BEFORE_OPENING_ANGLE_BRACKET_IN_TYPE_PARAMETER-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters"
                 value="do not insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=Java:SPACE_AFTER_CLOSING_ANGLE_BRACKET_IN_TYPE_ARGUMENT-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments"
                 value="do not insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=Java:<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block" value="insert"/>

        <!--IDEA使用了对应的配置：Java:SPACE_WITHIN_ARRAY_INITIALIZER_BRACES，但感觉不太好，IDEA默认不插入，Eclipse也使用不插入-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer"
                 value="do not insert"/>

        <!--use default insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return"
                 value="insert"/>

        <!--use default do not insert -->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch" value="do not insert"/>


        <!--use default insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration"
                 value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw"
                 value="insert"/>


        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=Java:SPACE_BEFORE_SWITCH_LBRACE-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch" value="insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=Java:SPACE_BEFORE_CLASS_LBRACE-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration"
                 value="insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=Java:<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block" value="insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=Java:SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer"
                 value="insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=Java:SPACE_BEFORE_METHOD_LBRACE-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration"
                 value="insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=Java:SPACE_AFTER_QUEST-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional" value="insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=Java:SPACE_BEFORE_QUEST-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional" value="insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=Java:SPACE_BEFORE_ANOTATION_PARAMETER_LIST-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation"
                 value="do not insert"/>

        <!--use default do not insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_ellipsis" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast" value="do not insert"/>
        <setting
                id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration"
                value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression"
                 value="do not insert"/>

        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference"
                 value="do not insert"/>


        <!--下面两个对应IDEA中的一个配置Java:SPACE_AROUND_ASSIGNMENT_OPERATORS，使用insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator" value="insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=Java:SPACE_BEFORE_CATCH_PARENTHESES-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch" value="insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=Java:SPACE_BEFORE_METHOD_CALL_PARENTHESES-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation"
                 value="do not insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try=Java:SPACE_BEFORE_TRY_PARENTHESES-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try" value="insert"/>

        <!--下面两个对应IDEA中的一个配置Java:SPACE_AROUND_UNARY_OPERATOR，使用do not insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_unary_operator" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_unary_operator" value="do not insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=Java:SPACE_BEFORE_IF_PARENTHESES-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if" value="insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=Java:SPACE_BEFORE_WHILE_PARENTHESES-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while" value="insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=Java:SPACE_AFTER_TYPE_CAST-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast" value="do not insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=Java:SPACE_BEFORE_METHOD_PARENTHESES-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration"
                 value="do not insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=Java:SPACE_BEFORE_FOR_PARENTHESES-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for" value="insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=Java:SPACE_BEFORE_SYNCHRONIZED_PARENTHESES-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized" value="insert"/>

        <!--org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=Java:SPACE_BEFORE_SWITCH_PARENTHESES-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch" value="insert"/>

        <!--下面两个对应IDEA中的一个配置Java:SPACE_AROUND_LAMBDA_ARROW，使用insert-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_lambda_arrow" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_lambda_arrow" value="insert"/>
        <!--SPACE_WITHIN_EMPTY_ARRAY_INITIALIZER_BRACES-->
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer"
                 value="do not insert"/>

        <!--Idea -> Wrapping And Braces -> Simple classes in one line -->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration" value="do not insert"/>
        <!--Idea -> Wrapping And Braces -> Simple method in one line -->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body" value="do not insert"/>
        <!--因为Idea不支持配置，所以设置为 Idea默认值-->

        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_enum_constant"
                 value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_type_annotation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_label" value="insert"/>
        <!--Idea可以通过Wrap Always实现 TODO-->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type" value="insert"/>
        <!--Idea -> Wrapping And Braces -> Simple block in one line -> do not select -->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block" value="insert"/>

        <!--Idea -> Wrapping And Braces -> try statement -> catch.... (Java:CATCH_ON_NEW_LINE)-->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement"
                 value="do not insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing" value="do not insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=Java:ARRAY_INITIALIZER_RBRACE_ON_NEXT_LINE-->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer"
                 value="do not insert"/>
        <!--#org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=Java:ARRAY_INITIALIZER_LBRACE_ON_NEXT_LINE-->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer"
                 value="do not insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=Java:ELSE_ON_NEW_LINE-->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement" value="do not insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=Java:WHILE_ON_NEW_LINE-->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement"
                 value="do not insert"/>
        <!--org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=Java:FINALLY_ON_NEW_LINE-->
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement"
                 value="do not insert"/>

        <!--comment start-->
        <setting id="org.eclipse.jdt.core.formatter.comment.line_length" value="120"/>
        <!--ENABLE_JAVADOC_FORMATTING-->
        <setting id="org.eclipse.jdt.core.formatter.comment.format_javadoc_comments" value="true"/>
        <!--org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment" value="false"/>
        <!--IDEA无对应设置，所以关闭对block comment的格式化 -->
        <setting id="org.eclipse.jdt.core.formatter.comment.format_block_comments" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries" value="true"/>

        <!--org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=Java:KEEP_FIRST_COLUMN_COMMENT-->
        <setting id="org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column" value="false"/>
        <!--org.eclipse.jdt.core.formatter.use_on_off_tags=FORMATTER_TAGS_ENABLED-->
        <setting id="org.eclipse.jdt.core.formatter.use_on_off_tags" value="true"/>
        <!--org.eclipse.jdt.core.formatter.disabling_tag=FORMATTER_OFF_TAG-->
        <setting id="org.eclipse.jdt.core.formatter.disabling_tag" value="@formatter:off"/>
        <!--org.eclipse.jdt.core.formatter.enabling_tag=FORMATTER_ON_TAG-->
        <setting id="org.eclipse.jdt.core.formatter.enabling_tag" value="@formatter:on"/>

        <!--下面的没有IDEA对应项，在代码里面对IDEA中使用默认值即可,LINE_COMMENT_AT_FIRST_COLUMN BLOCK_COMMENT_AT_FIRST_COLUMN设置为false-->
        <setting id="org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.indent_root_tags" value="true"/>

        <setting id="org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments"
                 value="false"/>


        <setting id="org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.format_line_comments" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.format_header" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries" value="true"/>

        <setting id="org.eclipse.jdt.core.formatter.comment.format_source_code" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.format_html" value="true"/>

        <setting id="org.eclipse.jdt.core.formatter.join_lines_in_comments" value="true"/>
        <!--和IDEA保持一致，注释换行-->
        <setting id="org.eclipse.jdt.core.formatter.comment.indent_parameter_description" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter" value="insert"/>


        <!--comment end-->

        <!--org.eclipse.jdt.core.formatter.blank_lines_after_imports=Java:BLANK_LINES_AFTER_IMPORTS-->
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_after_imports" value="1"/>
        <!--org.eclipse.jdt.core.formatter.blank_lines_before_imports=Java:BLANK_LINES_BEFORE_IMPORTS-->
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_imports" value="1"/>
        <!--org.eclipse.jdt.core.formatter.blank_lines_after_package=Java:BLANK_LINES_AFTER_PACKAGE-->
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_after_package" value="1"/>
        <!--org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=Java:BLANK_LINES_AROUND_CLASS-->
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations" value="1"/>
        <!--org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=Java:BLANK_LINES_BEFORE_METHOD_BODY-->
        <setting id="org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body" value="0"/>
        <!--org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=Java:<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration" value="0"/>
        <!--org.eclipse.jdt.core.formatter.blank_lines_before_field=Java:BLANK_LINES_AROUND_FIELD-->
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_field" value="0"/>
        <!--org.eclipse.jdt.core.formatter.blank_lines_before_method=Java:BLANK_LINES_AROUND_METHOD-->
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_method" value="1"/>
        <!--org.eclipse.jdt.core.formatter.blank_lines_before_package=Java:BLANK_LINES_BEFORE_PACKAGE-->
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_package" value="0"/>

        <!--下面IDEA没有对应设置，使用对应值即可-->
        <setting id="org.eclipse.jdt.core.formatter.align_fields_grouping_blank_lines" value="2147483647"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_member_type" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_between_import_groups" value="1"/>

        <!--org.eclipse.jdt.core.formatter.indentation.size=Java:IndentOptions:INDENT_SIZE-->
        <setting id="org.eclipse.jdt.core.formatter.indentation.size" value="4"/>
        <!--org.eclipse.jdt.core.formatter.continuation_indentation=Java:IndentOptions:<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.continuation_indentation" value="1"/>
        <!--org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=Java:<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header" value="true"/>
        <!--org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=Java:IndentOptions:SMART_TABS-->
        <setting id="org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations" value="false"/>
        <!--org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=Java:INDENT_CASE_FROM_SWITCH-->
        <setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch" value="true"/>
        <!--KEEP_INDENTS_ON_EMPTY_LINES-->
        <setting id="org.eclipse.jdt.core.formatter.indent_empty_lines" value="false"/>
        <!--org.eclipse.jdt.core.formatter.tabulation.size=Java:IndentOptions:<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.tabulation.size" value="4"/>
        <!--Java:IndentOptions:<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.tabulation.char" value="space"/>


        <!--下面IDEA没有对应设置，使用对应值即可-->
        <setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_block" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header"
                 value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer" value="1"/>

        <setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header"
                 value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_body" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header"
                 value="true"/>


        <!--Java:<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_assignment" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_binary_expression" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_resources_in_try" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_conditional_expression" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer" value="16"/>

        <!--下面没有对应的IDEA设置，Eclipse先使用对应值-->
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_enum_constants" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_parameterized_type_references" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_type_parameters" value="16"/>

        <setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration" value="16"/>


        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_method_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_compact_if" value="16"/>

        <setting id="org.eclipse.jdt.core.formatter.alignment_for_type_arguments" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression"
                 value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_multiple_fields" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_expressions_in_for_loop_header" value="16"/>

        <!--IDEA默认配置在同一行，Eclipse使用对应值即可-->
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_for_statment" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_method_invocation" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_switch_statement" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_enum_constant_declaration"
                 value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_if_while_statement" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_catch_clause" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_annotation" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_try_clause" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_method_delcaration" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_lambda_declaration" value="common_lines"/>

        <!--Java:BINARY_OPERATION_SIGN_ON_NEXT_LINE-->
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_binary_operator" value="true"/>

        <!--ASSIGNMENT_WRAP 需要设置为 WRAP_AS_NEEDED  WRAP_AS_NEEDED . Add in jdt.core-3.12，it's not work in previous version -->
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_assignment_operator" value="false"/>

        <!--IDEA无配置项，Eclipse使用对应值即可-->
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_conditional_operator" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line" value="false"/>

        <!--org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=Java:KEEP_CONTROL_STATEMENT_IN_ONE_LINE-->
        <setting id="org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line" value="false"/>
        <!--org.eclipse.jdt.core.formatter.compact_else_if=Java:SPECIAL_ELSE_IF_TREATMENT-->
        <setting id="org.eclipse.jdt.core.formatter.compact_else_if" value="true"/>
        <!--Java:ALIGN_GROUP_FIELD_DECLARATIONS-->
        <setting id="org.eclipse.jdt.core.formatter.align_type_members_on_columns" value="false"/>
        <!--Java:<Programmatic>-->
        <setting id="org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.join_wrapped_lines" value="true"/>

        <!--统一为end_of_lint，IDEA默认一致-->
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_method_declaration" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_block" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_lambda_body" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_block_in_case" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration"
                 value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_switch" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_array_initializer" value="end_of_line"/>


        <!--        <setting id="org.eclipse.jdt.core.compiler.source" value="1.8"/>
                <setting id="org.eclipse.jdt.core.compiler.compliance" value="1.8"/>
                <setting id="org.eclipse.jdt.core.compiler.codegen.targetPlatform" value="1.8"/>
                        <setting id="org.eclipse.jdt.core.compiler.problem.enumIdentifier" value="error"/>
                                <setting id="org.eclipse.jdt.core.compiler.problem.assertIdentifier" value="error"/>
                                        <setting id="org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode" value="enabled"/>
                -->
        <!--Java:KEEP_SIMPLE_BLOCKS_IN_ONE_LINE-->
        <setting id="org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line" value="false"/>

        <!--Java:CLASS_BRACE_STYLE，统一使用end_of_line TODO-->
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_constant" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_type_declaration" value="end_of_line"/>

        <!--org.eclipse.jdt.core.formatter.lineSplit=RIGHT_MARGIN-->
        <setting id="org.eclipse.jdt.core.formatter.lineSplit" value="120"/>
    </profile>
</profiles>
```

# 十、程序员身份认识

我们是工程师，不是搬运工，正确理解自身价值。给自己更高的要求。

虽然可能我们还没有这么优秀, 但是这也不影响我们要注入这样的潜意识, 相信潜移默化的力量。加油，奥利给💪

## 1. 第一身份

软件开发工程师,对代码负责,对设计负责。

提升自身编码能力, 驱动业务进步。产出设计文档和技术文档。

立足当下, 拥抱未来，拥抱变化。技术驱动型，面向未来设计。

## 2. 第二身份

我们是项目的参与者也可能是管理者，要有全局观念，Ower观念，站在全局的维度看整体。

## 3. 第三身份

业务驱动，产品驱动，公司核心竞争力，发展方向。